/*트리거 

1. TRIGGER
2. DML(INSERT, UPDATE, DELETE) 수행 후 트리거가 자동으로 수행
3. DML 직전에 수행되는 BEFORE 트리거, 직후에 수행되는 AFTER 트리거가 있음
4. 기본적으로 작업이 수행되는 행(ROW) 단위로 트리거가 적용됨. 
5. CREATE [OR REPLACE] TRIGGER 트리거_이름
6. [ALTER | BEFORE]
   [INSERT OR UPDATE OR DELETE]         --  트리거를 불러서 확인하는건 안되고 트리거가 잘 수행되는지 확인할거임
   [ON 테이블_이름]
   [FOR EACH ROW]
   BEGIN
        트리거 작업
    END[트리거_이름];
*/

--트리거 TRIG1 정의 
CREATE OR REPLACE TRIGGER TRIG1
    AFTER -- AFTER, BEFORE
    UPDATE -- INSERT OR UPDATE OR DELETE
    ON DEPARTMENT -- DEPARTMENT 테이블을 UPDATE할 때 동작함
    FOR EACH ROW -- UPDATE되는 행마다 트리거가 동작함
BEGIN
    DBMS_OUTPUT.PUT_LINE('HELLO WORLD');
END TRIG1;


--트리거 TRIG1동작 확인
UPDATE DEPARTMENT
 SET LOCATION = '인천'
WHERE DEPT_NO = 1;


--트리거 TRIG2 정의 
CREATE OR REPLACE TRIGGER TRIG2
    AFTER
    INSERT OR UPDATE OR DELETE -- 작성 순서 없음
    ON DEPARTMENT
    FOR EACH ROW
BEGIN
    IF INSERTING THEN 
        DBMS_OUTPUT.PUT_LINE('INSERT 이후 동작');
    ELSIF UPDATING THEN
        DBMS_OUTPUT.PUT_LINE('UPDATE 이후 동작');
    ELSIF DELETING THEN
        DBMS_OUTPUT.PUT_LINE('DELETE 이후 동작');
    END IF;
END TRIG2;


--트리거 TRIG2 동작 확인

delete from department 
where dept_no = 5;

INSERT INTO DEPARTMENT (DEPT_NO, DEPT_NAME, LOCATION) VALUES(5,'개발부','제주도')
UPDATE DEPARTMENT SET LOCATION = '경주' WHERE DEPT_NO =2;
DELETE FROM DEPARTMENT WHERE DEPT_NO = 3;

ROLLBACK;  -- 롤백 이전 커밋까지. 두번한다고 해서 두번 뒤로 가는거 아님
commit;
SET SERVEROUTPUT ON;

-- 트리거 TRIG3 정의 (★)
-- OLD 테이블 확인
-- 1. INSERT,UPDATE,DELETE 수행 이전 정보가 저장되는 테이블
-- 2. 오라클에서는 :OLD로 호출 
-- 3. AFTER 트리거와 함께 사용한다 
    -- 1) INSERT 동작 이전 : NULL
    -- 2) UPDATE 동작 이전 : 수정 전 데이터 
    -- 3) DELETE 동작 이전 : 삭제 된 데이터
    
CREATE OR REPLACE TRIGGER TRIG3
    AFTER 
    UPDATE OR DELETE
    ON EMPLOYEE
    FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE(:OLD.NAME);
END TRIG3;

--트리거 TRIG3 동작 확인
UPDATE EMPLOYEE
    SET NAME = '팥창민'
WHERE EMP_NO = '1001';
DELETE FROM EMPLOYEE WHERE EMP_NO = '1001';



--트리거 최종 실습
-- 목표 : 사원(EMPLOYEES)테이블에서 사원정보를 퇴사자(RETIRES)테이블에 삽입하기



--1) 퇴사자 테이블 만들기(EMPLOYEES 테이블과 동일한 구조, 데이터 없이 복사하기)

DROP TABLE RETIRES;

CREATE TABLE RETIRES AS
SELECT *
FROM EMPLOYEES
WHERE 1=2;
--2) RETIRE_ID, RETIRE_DATE 칼럼 추가하기 
ALTER TABLE RETIRES
ADD RETIRE_ID NUMBER;

ALTER TABLE RETIRES
ADD RETIRE_DATE DATE;



--3) RETIRE_ID 기본키 설정하기 

ALTER TABLE RETIRES
ADD CONSTRAINT RETIRE_PK PRIMARY KEY (RETIRE_ID);


--4) RETIRES_SEQ 시퀀스 생성하기 
DROP SEQUENCE RETIRES_SEQ;

CREATE SEQUENCE RETIRES_SEQ
  INCREMENT BY 1 
  NOCYCLE
  NOCACHE;

--5) RETIRE_TRIG 트리거 생성하기 

CREATE OR REPLACE TRIGGER RETIRE_TRIG
    AFTER DELETE 
    ON EMPLOYEES
    FOR EACH ROW
BEGIN
    INSERT INTO RETIRES(RETIRE_ID, RETIRE)


--6) EMPLOTEES 테이블의 데이터 DELETE 수행하기(RETIRE_TRIG 동작 확인);
                --세번째부터 삭제된 데이터는 OLD에 들어감
                
                
    
